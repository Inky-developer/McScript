[Wrapper]
testResult = 0
fun test() -> Boolean {{
  {}
}}
testResult = test()
if (testResult == 1) execute('tellraw @a ["",{{"text":"["}},{{"text":"McScript","color":"gold"}},{{"text":"] ["}},{{"text":"Test {index} of {count} ({name})","color":"gray"}},{{"text":"] "}},{{"text":"Success!","color":"dark_green"}}]');
else execute('tellraw @a ["",{{"text":"["}},{{"text":"McScript","color":"gold"}},{{"text":"] ["}},{{"text":"Test {index} of {count} ({name})","color":"gray"}},{{"text":"] "}},{{"text":"Failure!","color":"red"}}]');

[Sum]
return 1 + 1 == 2;

[Subtraction]
return 2 - 1 == 1;

[Product]
return 2 * 5 == 10;

[Division]
return 4 / 2 == 2;

[Division]
return 3 / 2 == 1;

[Modulo]
return 25 % 5 == 0;

[Modulo]
return 27 % 5 == 2;

[Boolean_and]
a = 1;
b = 2;
return a == 1 and b == 2;

[Boolean_and]
a = 1;
return not (a == 2) and 2 == 2;

[Boolean_or]
a = 1;
b = 2;
return a == 2 or b == 2;

[Boolean_or]
a = 1;
return not (a == 2);

[Function]
fun sum_and_square(a: Number, b: Number) -> Number {
    myFancyVar = a + b;
    return myFancyVar * myFancyVar;
}

return sum_and_square(6,6) + 6 == 150;

[If]
a = 1;
if (a == 0)
    a = 2;
else {a = 0;}
return a == 0;

[InPlaceOperator]
a = 10;
a += 5;
a *= 2;
a -= 10;
a /= 10;
return a == 2;

[While]
n = 5;
s = 0;
while (n > 0) {
    s += n;
    n -= 1;
}
return s == 15;

[Enum]
enum myEnum {
    a;
    b;
    c = 100;
}
return myEnum.a==0 and myEnum.b==1 and myEnum.c==100;

[Factorial]
fun fac(n: Number) -> Number {
    ret = 1;
    while (n > 1) {
        ret *= n;
        n -= 1;
    }
    return ret;
}

return fac(5) == 120;

[static_fixed_point_sum]
const a = 1.5;
const b = 2.75;

return a + b == 4.25;

[static_fixed_point_difference]
const a = 1.5;
const b = 2.75;

return a - b == -1.25;

[static_fixed_point_product]
const a = 1.5;
const b = 2.75;

return a * b == 4.125;

[static_fixed_point_division]
const a = 1.5;
const b = 2;

return a / b == 0.75;

[static_fixed_point_modulo]
const a = 15.5;
const b = 2.5;

return a % b == 0.5;

[fixed_point_sum]
a = 1.25;
b = 2.75;

return a + b == 4.0;

[fixed_point_difference]
a = 1.25;
b = 2.75;

return a - b == -1.5;

[fixed_point_product]
a = 1.25;
b = 2.75;

# the exact value is 3.4375, so to 3.438 would be rounded correctly.
return a * b == 3.437;

[fixed_point_division]
a = 1.25;
b = 2;

return a / b == 0.625;

[function_setBlock]
const block = blocks.player_head;
setBlock(blocks.air);
isAir = isBlock(blocks.air);
setBlock(block);
isTheBlock = isBlock(block);
return isAir and isTheBlock;

[function_evaluate]
const score = ".ret";
const namespace = "mcscript_tests";
execute(stringFormat("scoreboard players set $ $ 1", score, namespace));
return evaluate("scoreboard players get $score $namespace") == 1;

[function_random_chance]
i = 0;
allOne = boolean(1);
while (i < 1000) {
    ++i;
    allOne = allOne and randomChance(1);
}
return allOne;

[unary_minus]
return -(5*5) == -25;

[unary_minus]
a = 5;
return -a*a == -25;

[increment_one]
a = 0;
++a;
b = 0.0;
++b;
return a == 1 and b == 1.0;

[decrement_one]
a = 1;
--a;
b = 1;
--b;
return a == 0 and b == 0.0;

[struct]
struct Test {
    a: Number;
    b: Number;
}
number = 1;
t = Test(number, 2);
return t.a == 1 and t.b == 2;

[struct_modify]
struct Test {
    a: Number;
    b: Number;
}

t = Test(1, 2);
temp = t.a;
t.a = t.b;
t.b = temp;
return t.a == 2 and t.b == 1;


[inline_function]
fun sum(a: Number, b: Number) -> Number {
    return a + b;
}

inline fun doOperation(operation: Function, a: Number, b: Number) -> Number {
    return operation(a, b);
}

return doOperation(sum, 1, 2) == 3;

[inline_function]
struct Modifiable {
    a: Number;
}

inline fun doSomething(a: Number, b: Modifiable) -> Null {
    ++a;
    b.a += 1;
}

m = Modifiable(1);
a = 1;
doSomething(a, m);
return a == 1 and m.a == 2;

[check_builtins_run]
# don't validate the results, just check that the functions can run
a = boolean(12.5);
b = evaluate("setblock ~ ~ ~ minecraft:stone");
c = execute("say test");
d = fixed(1);
e = getBiome();
f = getBlock();
f = getBlock(0, -1, 0);
g = getLightLevel();
h = isBlock(blocks.stone);
i = isFeature(features.village);
j = isRaining();
k = isThundering();
l = randomChance(0.5);
m = random();
n = setBlock(blocks.air);
n = setBlock(blocks.air, 0, -1, 0);
const o = stringFormat("Test");
run for @a {
    print("test");
    actionbar("Test");
    title("tEsT");
    subtitle("TeSt");
}

return True;
