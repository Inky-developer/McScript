# basic selectors can be used just like in minecraft:
static all_players = @a

# it is also possible to specify filters:
static all_armor_stands = @e[type=armor_stand]

# to mimic the execute as . at @s behavior one can write:
run for @a at @s {
    # do stuff here
}

# for example it is possible to output some text in the run for loop:
run for @a print("Hello world!")

# Selectors can be printed as well:
run for @a print("Hello, {}!", @s)

# one problem with selectors is that the entities that select might change during the program
# consider:
static armor_stands = @e[type=armor_stand]
execute("summon armor_stand ~ ~ ~ {Tags:['mcscript_demo']}")
run for @a print("{}", armor_stands)

# It might not be the intention of the programmer to print the newly summoned armor stand.
# To circumvent problems like this, mcscript allows rvalue selectors. Basically this means:
armor_stands = @e[type=armor_stand]
# Note the there is no 'const' keyword.
# This line of code will make a snapshot of all armor stands that exist at the moment this line is executed.
# So any new summoned armor stand won't be listed by this selector.

# Instead of the run for ... construct one may also use a for-loop:
# This will not uses const selectors so "for ()"with selectors if a bit slower than "run for"
for (player in @a) {
    # player is equivalent to player = @s
    # do something
}
# A for loop is mostly equivalent to run for @. at @s {...}

# Here is a little example to show how powerful selectors can be
for (entity in @e) {
    # Run for all players and print the name of 'entity'
    run for @a print("message for player {}: Found entity {}", @s, entity)
}

# kill the summoned armor stand
run for @a print("{}", kill(@e[tag=mcscript_demo]))

# Using the $-placeholder syntax which is also used for strings, constants can be embedded into the selector
# at compile time:
static TAG = "mcscript_marker"
static MARKER = @e[type=armor_stand,tag=$TAG]
