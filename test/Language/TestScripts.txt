[Wrapper]
testResult = 0
fun test() -> Boolean {{
  {}
}}
testResult = test()
if (testResult == 1) execute('tellraw @a ["",{{"text":"["}},{{"text":"McScript","color":"gold"}},{{"text":"] ["}},{{"text":"Test {index} of {count} ({name})","color":"gray"}},{{"text":"] "}},{{"text":"Success!","color":"dark_green"}}]');
else execute('tellraw @a ["",{{"text":"["}},{{"text":"McScript","color":"gold"}},{{"text":"] ["}},{{"text":"Test {index} of {count} ({name})","color":"gray"}},{{"text":"] "}},{{"text":"Failure!","color":"red"}}]');

[Sum]
return 1 + 1 == 2;

[Subtraction]
return 2 - 1 == 1;

[Product]
return 2 * 5 == 10;

[Division]
return 4 / 2 == 2;

[Division]
return 3 / 2 == 1;

[Modulo]
return 25 % 5 == 0;

[Modulo]
return 27 % 5 == 2;

[Boolean_and]
a = 1;
b = 2;
return a == 1 and b == 2;

[Boolean_and]
a = 1;
return not (a == 2) and 2 == 2;

[Boolean_or]
a = 1;
b = 2;
return a == 2 or b == 2;

[Boolean_or]
a = 1;
return not (a == 2);

[Function]
fun sum_and_square(a: Number, b: Number) -> Number {
    myFancyVar = a + b;
    return myFancyVar * myFancyVar;
}

return sum_and_square(6,6) + 6 == 150;

[If]
a = 1;
if (a == 0)
    a = 2;
else {a = 0;}
return a == 0;

[InPlaceOperator]
a = 10;
a += 5;
a *= 2;
a -= 10;
a /= 10;
return a == 2;

[While]
n = 5;
s = 0;
while (n > 0) {
    s += n;
    n -= 1;
}
return s == 15;

[DoWhile]
a = 0
do {
    ++a
} (a < 0)

b = 0
while (b < 0) {
    ++b
}

return a == 1 and b == 0

[Enum]
enum myEnum {
    a;
    b;
    c = 100;
}
return myEnum.a==0 and myEnum.b==1 and myEnum.c==100;

[Factorial]
fun fac(n: Number) -> Number {
    ret = 1;
    while (n > 1) {
        ret *= n;
        n -= 1;
    }
    return ret;
}

return fac(5) == 120;

[static_fixed_point_sum]
static a = 1.5;
static b = 2.75;

return a + b == 4.25;

[static_fixed_point_difference]
static a = 1.5;
static b = 2.75;

return a - b == -1.25;

[static_fixed_point_product]
static a = 1.5;
static b = 2.75;

return a * b == 4.125;

[static_fixed_point_division]
static a = 1.5;
static b = 2;

return a / b == 0.75;

[static_fixed_point_modulo]
static a = 15.5;
static b = 2.5;

return a % b == 0.5;

[fixed_point_sum]
a = 1.25;
b = 2.75;

return a + b == 4.0;

[fixed_point_difference]
a = 1.25;
b = 2.75;

return a - b == -1.5;

[fixed_point_product]
a = 1.25;
b = 2.75;

# the exact value is 3.4375, so to 3.438 would be rounded correctly.
return a * b == 3.437;

[fixed_point_division]
a = 1.25;
b = 2;

return a / b == 0.625;

[function_setBlock]
static block = blocks.player_head;
setBlock(blocks.air);
isAir = isBlock(blocks.air);
setBlock(block);
isTheBlock = isBlock(block);
return isAir and isTheBlock;

[function_evaluate]
static score = ".ret";
static namespace = "mcscript_tests";
execute(stringFormat("scoreboard players set $ $ 1", score, namespace));
return evaluate("scoreboard players get $score $namespace") == 1;

[function_random_chance]
i = 0;
allOne = boolean(1);
while (i < 1000) {
    ++i;
    allOne = allOne and randomChance(1.0);
}
return allOne;

[unary_minus]
return -(5*5) == -25;

[unary_minus]
a = 5;
return -a*a == -25;

[increment_one]
a = 0;
++a;
b = 0.0;
++b;
return a == 1 and b == 1.0;

[decrement_one]
a = 1;
--a;
b = 1;
--b;
return a == 0 and b == 0.0;

[struct]
struct Test {
    a: Number;
    b: Number;
}
number = 1;
t = Test(number, 2);
return t.a == 1 and t.b == 2;

[struct_modify]
struct Test {
    a: Number;
    b: Number;
}

t = Test(1, 2);
temp = t.a;
t.a = t.b;
t.b = temp;
return t.a == 2 and t.b == 1;


[inline_function]
fun sum(a: Number, b: Number) -> Number {
    return a + b;
}

inline fun doOperation(operation: Function, a: Number, b: Number) -> Number {
    return operation(a, b);
}

return doOperation(sum, 1, 2) == 3;

[inline_function]
struct Modifiable {
    a: Number;
}

inline fun doSomething(a: Number, b: Modifiable) -> Null {
    ++a;
    b.a += 1;
}

m = Modifiable(1);
a = 1;
doSomething(a, m);
return a == 1 and m.a == 2;

[array]
a = array(2);
a[0] = 2;
a[1] = 3;
return a[0] * a[1] == 6;

[array]
a = 2;
b = 3;
a = arrayOf(a, b);
return a[0] * a[1] == 6;

[array_unpacking]
var = 3
a = arrayOf(1, 2, var)

(value1, value2, value3) = a
return value1 == 1 and value2 == 2 and value3 == 3

[list]
a = list(types.Number);

end = True;
for (i in range(10)) {
    if (end) {
        a.append(i*i);
    } else {
        a.insert(0, i*i);
    }
    end = not end;
}
# no simple list comparison yet
run for @a print("{}", a);

return True

[string]
s = "test string";
s[0] = "p";
for (char in s) {
    print("{}", char);
}
return True;

[for_loop]
array = arrayOf(1, 2, 3, 4, 5, 6);
sum = 0;
for (i in array) {
    if (i % 2) sum += i;
}
return sum == 9;

[non_static_selector]
players = @a
for (player in players) {
    current_player = players
    run for @a print("{}", current_player)
}
return True

[custom_scoreboard]
player_count = 0
for (player in @a) ++player_count
return_value = True
if (player_count != 0) {
    any_player = @p
    start_val = any_player["test"]
    any_player["test"] = 10
    return_value = start_val == 0 and any_player["test"] == 10
}
return return_value

[check_builtins_run]
# don't validate the results, just check that the functions can run
a = boolean(12.5);
b = evaluate("setblock ~ ~ ~ minecraft:stone");
c = execute("say test");
d = fixed(1);
e = getBiome();
f = getBlock();
f = getBlock(0, -1, 0);
g = getLightLevel();
h = isBlock(blocks.stone);
i = isFeature(features.village);
j = isRaining();
k = isThundering();
l = randomChance(0.5);
m = random();
n = setBlock(blocks.air);
n = setBlock(blocks.air, 0, -1, 0);
static o = stringFormat("Test");
run for @a {
    print("test");
    actionbar("Test");
    title("tEsT");
    subtitle("TeSt");
}
p = array(5);
q = arrayOf(10);
r = range(10);
r = range(10, -1, -1);
s = list(types.Number);

return True;
